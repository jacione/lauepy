# -*- coding: utf-8 -*-
"""
Classes for simulating a Laue diffraction on 2D area detectors

classes:
    Reflection
    LaueSimulation

Author : Xu, Ruqing
Created: Thu Jan 14 18:36:04 2016
"""

import collections
from copy import deepcopy
from functools import wraps
from time import time as timemeth

import numpy as np

from src.lauepy.rxlibs.xmd34 import geometry as geo
from src.lauepy.rxlibs.xmd34 import lattice as latt
from src.lauepy.rxlibs.xmd34 import utils


def measure(func):
    @wraps(func)
    def _time_it(*args, **kwargs):
        start = int(round(timemeth() * 1000))
        try:
            return func(*args, **kwargs)
        finally:
            end_ = int(round(timemeth() * 1000)) - start
            # print(f"Total execution time: {end_ if end_ > 0 else 0} ms")

    return _time_it


class Reflection(object):
    """
    Collection of related quanties & methods of a Bragg reflection

    Usage
    -----
    ::
        Reflection(hkl)

    Parameters
    ----------
        hkl : array-like
            an array with 3 elements that defines a reflection

    Methods
    -------
        gen_q_vec(xtal,rotation_matrix)
            generate q vector based on crystal lattice & rotation matrix
        calc_coords_on_detector(detector_geometry)
            compute pixel coordinates of this reflection according to the
            given detector_geometry

    Attibutes / Properties
    ----------------------
        hkl
            input hkl vector
        hkllabel
            (property) a string with the h,k,l numbers
        q
            scattering vector, calculated by calling self.gen_q_vec
        keV
            x-ray energy needed for this reflection, calculated by calling
            self.gen_q_vec
        keVlabel
            (property) a string with keV number printed
        k_out
            outgoing beam wavevector, calculated by calling self.gen_q_vec
        k_out_normalized
            (property) normalized k_out vector
        det_coords
            dict object generated by calling self.calc_coords_on_detector,
            has the form of {'detname1':(x1,y1),'detname2':(x2,y2),...}, with
            the keys being the "detname" filed of a given detector_geometry
        structure_factor
            defined for other programs to use, set to default of -1.0;
        sflabel
            (property) a string with the structure factor number
    """

    def __init__(self, hkl):
        self.hkl = np.array(hkl).astype('float32')
        self.q = None
        self.keV = None
        self.k_out = None
        self.det_coords = {}
        self.structure_factor = -1.0

    def gen_q_vec(self, xtal, rotation):
        """generate q vector based on xtal info and input rotation matrix"""
        self.q = np.dot(rotation, xtal.get_q_vec(self.hkl))
        self._calc_beam_k()

    def _calc_beam_k(self):
        """
        calculate beam energy and outgoing wavevector k_out
        vector, with option to be normalized
        """
        if self.q is not None:
            qx, qy, qz = self.q
            if qz < 0:  # only accessible if q is in the upstream half
                self.k_out = np.array([qx, qy, (-qz ** 2 + qx ** 2 + qy ** 2) / (-qz * 2)])
                k = (qx ** 2 + qy ** 2 + qz ** 2) / (-2 * qz)
                self.keV = utils.inv_m_to_keV(k)
            else:
                self.keV = np.nan

    @property
    def k_out_normalized(self):
        if self.k_out is not None:
            return self.k_out / np.linalg.norm(self.k_out)
        else:
            return None

    def calc_coords_on_detector(self, detgeometry):
        """
        Computes self.det_coords, which is a dict object with the form of
        {'detname1':(x1,y1),'detname2':(x2,y2),...}

        Input
        -----
            detgeometry
                should be of DetectorGeometry class
        """
        assert isinstance(detgeometry, geo.DetectorGeometry)
        detname = detgeometry.detname
        if self.k_out is None:
            self.det_coords[detname] = None
        else:
            coords = detgeometry.xyzs_to_pixels(self.k_out)
            if np.sum(np.isnan(coords)):
                self.det_coords[detname] = None
            else:
                self.det_coords[detname] = coords

    @property
    def hkllabel(self):
        return '{:g} {:g} {:g}'.format(self.hkl[0], self.hkl[1], self.hkl[2])

    @property
    def keVlabel(self):
        if self.keV:
            return '{:.3f}'.format(self.keV)
        else:
            return None

    @property
    def sflabel(self):
        return '{:.1f}'.format(self.structure_factor)


class FastLaueSimulation_list(object):
    """
    Collection of methods & data objects for a tweakable Laue Simulation

    Inputs:
        detectors & geometries (allows multiple)
        crystal structure
        crystal orientation matrix (optional)
    Data objects:
        peakpool
    User Methods:
        detector rotate around X/Y/Z/beam-center
        detector translations
        get sample rotate matrix/vector
        get detector rotate vector
        close
    """

    def __init__(self, hkl, detgeos, xtal, xtalrotation=None):
        self.detgeos = []
        if isinstance(detgeos, geo.DetectorGeometry):
            self.detgeos.append(deepcopy(detgeos))
        elif isinstance(detgeos, collections.Sequence) and \
                isinstance(detgeos[0], geo.DetectorGeometry):
            self.detgeos.extend(detgeos)

        # self.hkl=eulerparsehkl.extract_hkl(filename)
        self.hkl = hkl
        self.peakpool = [Reflection(hkl) for hkl in self.hkl]

        assert isinstance(xtal, latt.Xtal)
        self.xtal = xtal

        if xtalrotation is None:
            self.xtal_rot = np.identity(3)
        else:
            self.xtal_rot = np.array(xtalrotation)  # this will make an copy
            assert self.xtal_rot.shape == (3, 3)

        self.rotate_step_default = 5 * np.pi / 180.0  # default rotation step is 5 degrees

        # make copies of quanties that one might want to reset to after changes
        self._init_detgeos = deepcopy(self.detgeos)
        self._init_xtal_rot = deepcopy(self.xtal_rot)

    def reset_geometry(self):
        """
        Reset detector geometries and xtal rotation to initial values.
          re-generate peaks and plot if there are any
        """
        self.detgeos = deepcopy(self._init_detgeos)
        self.xtal_rot = deepcopy(self._init_xtal_rot)
        self.gen_det_peaks()

    def det_index(self, detid):
        """
        Return index of a detector in from its name,
        if input is an integer, then check its range.
        Raises ValueError if input not valid.
        """
        ### check detector id ###
        wrongid = False
        if detid in range(len(self.detgeos)):
            idet = detid
        elif isinstance(detid, str):
            try:
                idet = [detgeo.detname for detgeo in self.detgeos].index(detid)
            except:
                wrongid = True
        else:
            wrongid = True

        if wrongid:
            raise ValueError('Unrecognized detector id: {}'.format(detid))

        return idet

    @measure
    def gen_det_peaks(self):

        # The old self.__peak_coords_calc_n_verify modified the peaks to actually compute the position on the detector.
        # So need to lift that from the old method assuming a single detector.  Might delete multidet capability.
        detgeo = self.detgeos[0]
        detname = detgeo.detname
        for pk in self.peakpool:
            pk.gen_q_vec(self.xtal, self.xtal_rot)
            pk.calc_coords_on_detector(detgeo)
        #             print(np.round(pk.keV,0),'keV')
        self.xs = [pk.det_coords[detname][0] for pk in self.peakpool]
        self.ys = [pk.det_coords[detname][1] for pk in self.peakpool]
        self.hkls = [pk.hkllabel for pk in self.peakpool]

    def rotate_det(self, detid, axis, degree=None):
        """
        Method for user to rotate crystal and re-calcualte the simulation
        detid can either be an integer index or a string name of the detector.
        axis can be of different types:
            'X', 'Y', 'Z': pre-defined beamline axis
            'pcenter' : projected center of the sample on the detector plane
            (u,v,w) : an arbitrary axis given by this vector
        degree : angle to be rotated in degree, optional
        """
        idet = self.det_index(detid)
        detgeo = self.detgeos[idet]

        ### define axis ###
        if len(axis) == 3:
            rvec = np.array(axis)
        elif axis in 'Xx':
            rvec = np.array((1, 0, 0))
        elif axis in 'Yy':
            rvec = np.array((0, 1, 0))
        elif axis in 'Zz':
            rvec = np.array((0, 0, 1))
        elif axis == 'pcenter':
            # the proj. center rotation for the detector is different from that
            # for the xtal in that it's not around the q vector, but around the
            # position vector of the proj. center
            px, py = detgeo.proj_center
            rvec = detgeo.pixels_to_xyzs(px, py)
            rvec.shape = (3,)  # this line may be redundant
        else:
            raise ValueError("Unrecognized input '{}' for 'axis'".format(axis))
        # normalize axis vector
        rvec = rvec / np.linalg.norm(rvec)

        ### multiply by rotation angle ###
        if degree is None:
            rvec *= self.rotate_step_default
        else:
            rvec *= degree / 180.0 * np.pi
        ### make new rotation matrix ###
        rmat = geo.rot_vec_to_matrix(rvec)
        newdetrm = np.tensordot(rmat, detgeo.rmatrix, axes=(1, 0))
        newdetrv = geo.rot_matrix_to_vec(newdetrm)
        detgeo.rotation = newdetrv
        detgeo.update_rmatrix()

        ### update peak list ###
        self.gen_det_peaks()

    def translate_det(self, detid, vec, distance=None):
        """
        User method to change detector translation vector and then update
        the calculated peaks.
        If distance is not given, then vec is used as absolute values;
        otherwise, the change will be made in the direction of vec with
        the specified distance.
        """
        idet = self.det_index(detid)

        if distance is None:
            distance = 1.0

        v = np.array(vec).astype('float32')
        v = v / np.linalg.norm(v) * distance

        self.detgeos[idet].translation += v
        self.gen_det_peaks()
